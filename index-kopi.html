<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Map</title>
    <style>
      input[type='range'] {
        -webkit-appearance: none;
        width: 100%;
        height: 8px;
        outline: none;
        opacity: 0.8;
        transition: opacity 0.2s;
        border-radius: 4px;
      }

      input[type='range']:hover {
        opacity: 1; /* Slightly lighter when hovering */
      }

      /* Style the slider thumb */
      input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background-color: black; /* Black thumb */
        border: 2px solid #fff; /* Optional white border for contrast */
        border-radius: 50%;
        cursor: pointer;
      }

      input[type='range']::-moz-range-thumb {
        width: 18px;
        height: 18px;

        border: 2px solid #fff; /* Optional white border */
        border-radius: 50%;
        cursor: pointer;
      }

      input[type='range']::-ms-track {
        border-color: transparent;
        color: transparent;
      }

      body {
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
      }

      /* Container to stack elements vertically */
      .container {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      /* Optional styling for the slider */
      #yearSlider {
        width: 300px;
      }

      /* Styling for the text */
      #state-name {
        font-weight: bold;
      }
      #year {
        font-size: 1.2em;
        text-align: center;
      }

      .circle:hover {
        opacity: 0.5;
      }

      .tooltip {
        position: absolute;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <input type="range" step="4" id="yearSlider" class="slider" min="1976" max="2020" value="1976" />
      <p>Year: <span id="year">1976</span></p>
      <div id="state-name">Click on a state</div>
      <!-- Container for the map -->
      <div id="chart"></div>
    </div>

    <!-- D3.js and TopoJSON libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>

    <script>
      let stateInfo;
      const slider = document.getElementById('yearSlider');
      const output = document.getElementById('year');
      let debounceTimeout;
      output.innerHTML = slider.value;

      slider.oninput = async function () {
        output.innerHTML = this.value;
        // Clear the previous timeout
        clearTimeout(debounceTimeout);

        // Set a new timeout to call drawMap after a delay
        debounceTimeout = setTimeout(() => {
          console.log('DRAW MAP ');
          drawMap(this.value);
        }, 200); // 200ms delay (adjust as needed)
      };

      async function getStateWinners(year) {
        const electionData = await d3.json('./files/presidential_statelevel_1976-2020copy.json');

        // Filter data by the specified year
        // Filter data by the specified year
        const yearData = electionData.filter((entry) => entry.year === year);

        console.log('yearData', yearData);

        // Group data by state and find the winner in each state
        const stateWinners = yearData.reduce((acc, entry) => {
          // If the state is not already in the accumulator, add it
          if (!acc[entry.state]) {
            acc[entry.state] = { ...entry }; // Copy the entry to keep all its data
          } else {
            // If the state exists, check if the current entry has more votes than the stored entry
            if (entry.votes > acc[entry.state].votes) {
              acc[entry.state] = { ...entry }; // Update with the new winner
            }
          }
          return acc;
        }, {});

        // Convert the result to an array of objects for easier readability
        const result = Object.keys(stateWinners).map((state) => ({
          state,
          winner: stateWinners[state].party_detailed,
          total: stateWinners[state].total,
          votes: stateWinners[state].votes,
        }));

        return result;
      }

      async function drawMap() {
        // Load the data file
        const us = await d3.json(
          './files/75faaaca1f1a4f415145b9db520349a3a0b93a53c1071346a30e6824586a7c251f45367d9262ed148b7a2b5c2694aa7703f3ac88051abc65066fd0074fdf9c9e.json'
        );

        ///##########
        // create a tooltip
        var Tooltip = d3
          .select('#chart')
          .append('div')
          .attr('class', 'tooltip')
          .style('opacity', 0)
          .style('background-color', '#242424')
          .style('color', 'white')
          .style('padding', '15px')
          .style('border-radius', '10px');

        // ##########

        const width = 1075;
        const height = 710;
        const stateWins = await getStateWinners(output.innerHTML);
        console.log('Â¤Â¤Â¤Â¤Â¤Â¤Â¤Â¤', output.innerHTML);
        const zoom = d3.zoom().scaleExtent([1, 8]).on('zoom', zoomed);

        // Clear the existing SVG content before redrawing
        d3.select('#chart').select('svg').remove();
        const svg = d3
          .select('#chart')
          .append('svg')
          .attr('viewBox', [0, 0, width, height])
          .attr('width', width)
          .attr('height', height)
          .attr('style', 'max-width: 100%; height: auto;')
          .on('click', reset);

        const path = d3.geoPath();
        const g = svg.append('g');

        const states = g
          .append('g')
          .attr('fill', '#444') // Default color for uncolored states
          .attr('cursor', 'pointer')
          .selectAll('path')
          .data(topojson.feature(us, us.objects.states).features)
          .join('path')
          .attr('d', path)
          .attr('fill', (d) => {
            const stateName = d.properties.name; // Get state name from GeoJSON properties
            const stateData = stateWins.find((state) => state.state === stateName);

            if (stateData) {
              return stateData.winner === 'DEMOCRAT' ? '#dc5356' : '#5fb7e5';
            }
            return '#444'; // Default color if no match
          })
          .on('click', clicked)
          .on('mouseover', function (event, d) {
            Tooltip.style('opacity', 1); // Show tooltip on mouseover
          })
          .on('mousemove', function (event, d) {
            // Get state name from GeoJSON properties
            const stateName = d.properties.name;

            // Find the matching state data in `stateWins`
            const stateData = stateWins.find((state) => state.state === stateName);
            const [x, y] = d3.pointer(event);
            const zoomTransform = d3.zoomTransform(this.parentNode);
            // Update the tooltip content with state data if available
            Tooltip.html(
              stateData
                ? `  ${stateData.winner === 'DEMOCRAT' ? 'ðŸ”´' : 'ðŸ”µ'}  ${stateData.state} <br> Winner: ${stateData.winner} <br> Votes: ${
                    stateData.votes
                  }`
                : `State: ${stateName} <br> No data available`
            )
              .style('left', x * zoomTransform.k + zoomTransform.x + 'px') // Adjust for scale and translation
              .style('top', y * zoomTransform.k + zoomTransform.y + 'px'); // Adjust for scale and translation
          })
          .on('mouseleave', function () {
            Tooltip.style('opacity', 0); // Hide tooltip on mouseleave
          })
          .attr('class', 'circle');

        states.append('title').text((d) => d.properties.name);

        g.append('path')
          .attr('fill', 'none')
          .attr('stroke', 'white')
          .attr('stroke-linejoin', 'round')
          .attr('d', path(topojson.mesh(us, us.objects.states, (a, b) => a !== b)));

        svg.call(zoom);

        function reset() {
          states.transition().style('fill', null);
          svg
            .transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity, d3.zoomTransform(svg.node()).invert([width / 2, height / 2]));

          document.getElementById('state-name').innerText = 'Click on a state';
        }

        function clicked(event, d) {
          const [[x0, y0], [x1, y1]] = path.bounds(d);
          event.stopPropagation();
          states.transition().style('fill', null);

          // Display the clicked state's name
          document.getElementById('state-name').innerText = `State: ${d.properties.name}`;

          d3.select(this).transition().style('fill', 'green');
          svg
            .transition()
            .duration(750)
            .call(
              zoom.transform,
              d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height)))
                .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
              d3.pointer(event, svg.node())
            );
        }

        function zoomed(event) {
          const { transform } = event;
          g.attr('transform', transform);
          g.attr('stroke-width', 1 / transform.k);
        }
      }

      // Run the function to draw the map
      drawMap();
    </script>
  </body>
</html>
